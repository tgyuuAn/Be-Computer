### HTTP 란?

- Hyper Text Transfer Protocol
- 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response)으로 정보를 주고 받을 수 있는 프로토콜

<br><br><br>

### HTTP의 특성

1. 요청-응답 기반 프로토콜 : 요청 메시지, 응답 메시지 기반으로 동작하는 프로토콜
2. 미디어 독립적 프로토콜 : 자원을 요청할 뿐 자원의 특성을 제한하지 않는다.
3. Stateless 프로토콜 : 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다. _(안전성과 확장성을 위하여)_
4. 지속 연결을 지원하는 프로토콜 : 하나의 TCP 연결을 통해 여러 개의 TCP 요청을 주고 받을 수 있음.

<br><br><br>

### RESTful API 란 ?

- Representational State Transfer API
- API를 설계할 때 HTTP를 활용하여 자원을 다루는 설계 원칙
- 서버와 클라이언트 간의 통신은 이렇게 하면 좋아요~ 라는 뜻의 Best Practice

<br><br><br>

### HTTP 상태 코드

#### 200번대 : 성공 상태

- 200 : OK (요청이 성공했음)
- 201 : Created (요청이 성공했으며, 새로운 자원이 생성되었음) Location 헤더를 통해 생성된 자원의 위치를 명시
- 202 : Accepted (요청을 잘 받았으나, 작업이 끝나지 않았음)
- 204 : No Content (요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음)

#### 300번대 : 리다이렉션 상태

- 301 : Moved Permanently (영구 리다이렉션 : POST로 요청했을 시 GET으로 재요청 메서드 변경될 수 있음)
- 308 : Permanent Redirect (영구 리다이렉션 : POST로 요청했을 시 GET으로 재요청 메서드 변경되지 않음, 그대로 POST로 재요청)
- 302 : Found (일시 리다이렉션 : 재요청 메서드 변경될 수 있음)
- 303 : See Other (일시 리다이렉션 : 재요청 메서드가 GET으로 변경)
- 307 : Temporary Redirect (일시 리다이렉션 : 재요청 메서드 변경되지 않음)
- 304 : Not Modified ()

#### 400번대 : 클라이언트 에러 상태

- 400 : Bad Request (요청 자체가 잘못되었음)
- 401 : Unauthrozied (요청한 자원에 대한 유효한 인증이 없음, 인증이 되지 않았음)
- 403 : Forbidden (요청이 서버에 의해 거부됨, 인증이 되었는데 권한이 충분하지 않음)
- 404 : Not Found (요청된 자원을 찾을 수 없음)
- 405 : Method Not Allowed (요청한 메서드를 지원하지 않음)

#### 500번대 : 서버측 실패 상태

- 500 : Internal Error (서버 내부에서 에러가 발생)
- 502 : Bad Gatewat (중간 서버의 통신 오류)
- 503 : Service Unavailable (현재는 처리 불가하지만, 추후 가능할 수도 있음)

<br><br><br>

### HTTP의 발전

#### HTTP/0.9

- 현재는 거의 사용되지 않는 초창기 HTTP 버전
- GET 메소드만 사용 가능
- 헤더가 없음

#### HTTP/1.0

- HEAD, POST 등 GET 이외의 메서드 도입
- 헤더 도입
- 공식적으로는 지속 연결 미지원 (Hand Shake를 계속 해야함)

#### HTTP/1.1

- 오늘날까리 널리 사용되는 버전
- 지속 연결 지원
- 파이프라이닝, 콘텐츠 협상 기능 등 편의기능 추가
- 메시지 본문 = 평문
- HOL (Head Of Line Blocking) 문제가 존재함
- 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 경우, 앞의 패킷이 지연되면 이후의 패킷들 모두 지연되는 문제

#### HTTP/2.0

- 오늘날까리 널리 사용되는 버전
- HTTP/1.1의 효율과 성능을 높이기 위해 사용되는 버전
- 헤더 압축 전송 기능 추가
- 메시지 본문 = 바이너리 데이터
- 서버 푸시 기능 추가 _(클라이언트에서 요청하지 않더라도 미리 보내는 기능)_
- 멀티플랙싱 기능을 도입하여 HOL블로킹 완화 : 여러 스트림을 활용해 병렬적으로 메시지를 주고받을 수 있음

#### HTTP/3.0

- 점차 사용 확대되는 버전

- 이전까지는 TCP 기반 동작
- 3.0 부터는 UDP 기반 프로토콜인 QUIC 기반으로 동작
- 빠른 송수신 가능

<br><br><br>

### 암호화

- 네트워크 통신 시 평문으로 메세지를 주고 받으면 훔쳐보거나 탈취당할 수 있음
- 대칭키 암호화 : 암호화 및 복호화에 동일한 키를 사용하는 방법 _(비밀키 암호화)_
- 비대칭키 암호화 : 암호화 및 복호화에 서로 다른 키를 사용하는 방법 _(공개키 암호화)_
- 인증서 : 무엇인가를 증명하기 위해서 사용하는 것. _(주로 공개키를 인증하기 위해서 사용)_
- 인증 기관 : 인증서의 발급, 검증, 저장과 같은 역할을 수행하는 공인 기관
- 인증은 인증서를 CA의 개인키로 암호홤으로써 그것에 신뢰성을 부여함
- 이 인증서가 유효한 인증서인지 확인해보려는 클라이언트는 인증서를 해쉬 함수에 넣은 값과 서명을 CA의 공개키로 복호화했을 때 동일한 지 여부를 가지고 변조가 되었는 지 판단

### SSL 및 TLS

- HTTPS는 HTTP에 SSL이나 TLS가 합쳐진 프로토콜임.
- TLS는 SSL을 계승한 프로토콜임
- 웹 브라우저 URL 옆에 자물쇠 모양이 뜨면 HTTPS 기반으로 통신하고 있다는 것

#### HTTPS 송수신 단계

1. TCP의 3 way hand shake
2. TLS 핸드 쉐이크 _(키와 인증서를 전송)_
3. 암호화된 메시지 전송

#### TLS의 핸드 쉐이크

1. ClientHello
- 암호화된 통신을 위해 서로 맞춰봐야할 메시지를 전송
- TLS 버전, 사용 가능한 암호화 알고리즘 및 해시 함수, 키 생성에 필요한 난수 등 포함

2. ServerHello
- 클라이언트에서 제시된 정보들 중 하나를 선택, 키 생성에 필요한 난수를 전송

3. 서버는 클라이언트에게 인증서와 인증서 검증을 위한 서명값을 보냄
4. 클라이언트는 해당 인증서를 CA를 통해 유효한 인증서인지 확인
5. 클라이언트는 서버가 유효한 호스트인지 확인이 완료되었을 경우, 서버의 공개키를 이용하여 임의로 만든 마스터키를 암호화해서 전송
6. 서버는 자신의 개인키를 이용하여 클라이언트가 보낸 마스터키를 복호화한 후, 서버와 클라이언트가 서로 주고받았던 난수와 마스터키를 이용하여 동일한 세션 키(공통키)를 생성하고, 이 키를 이용하여 암호화된 메시지를 주고받음

#### 2-RTT, 1-RTT

- TLS 1.2까지는 TLS handshake가 위와 같이 2-RTT로 동작
- TLS 1.3부터는 TLS handshake를 최적화하여 1-RTT로 동작

1. ClientHello + 키 공유
2. ServerHello + Finished

#### 0-RTT

- TLS 1.3에서 도입된 기법으로 이전에 연결된 서버라면 재빠르게 연결할 수 있는 기법
- TCP Fast Open 처럼 한 번 연결되었다면 서버에 세션으로 해당 연결 정보를 저장, 이후 클라이언트는 연결할 때 세션 티켓을 이용해서 첫 Client Hello에 암호화된 요청까지 함께 전송
- 이후 서버는 세션 값이 유효환지 확인하고, 맞다면 요청을 처리함과 동시에 TLS shandshake를 마저 진행함

- 만약 0-RTT를 사용한다면 공격자가 해당 패킷을 탈취해서 재전송 공격을 할 수 있음.
- 이를 막기 위해서는 멱등성이 있는 GET 과 같은 요청에만 0-RTT를 적용하고, POST, PUT 등 멱등성이 없는 요청은 0-RTT 전송에서 제외.