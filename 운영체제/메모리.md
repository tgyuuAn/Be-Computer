### 스와핑

- 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역으로 쫓아내고(Swap-out),
- 그렇게 생긴 빈 공간에 새 프로세스를 적재(Swap-in)
- 프로세스들이 요구하는 메모리 공간 크기가 실제 메모리 크기보다 클 경우 이를 물리 메모리에 다 담을 수 없음
 
### 메모리 할당이란 ?

- 프로세스는 메모리의 빈 공간에 할당되어야 한다. 하지만 빈 공간이 여러개라면?
- 최초 적합, 최적 적합, 최악 적합을 사용할 수 있음.

<br><br><br>

### 외부 단편화

- 공간에 프로세스를 할당하고 남은 잉여 공간
- 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 압축을 진행함으로써 해결할 수가 있지만, 완전 탐색을 해야하므로 오버헤드가 발생함

### 내부 단편화

- 프로세스 메모리 공간에 고정된 크기의 메모리 공간으로 나누어서 외부 단편화를 없앰. 하지만 내부 공간에 잉여 공간이 생김

<br><br><br>

### 연속 메모리 할당

- 외부 단편화가 많아지는 부작용이 있는 방식
- 물리 메모리보다 큰 메모리가 필요할 경우 할당이 불가능한 문제
- 최초 적합, 최적 적합, 최악 적합의 방식이 있음

#### 최초 적합

- First-Fit
- 프로세스의 메모리 공간을 탐색하다가 들어갈 수 있는 최초의 공간을 찾으면 그 자리에 들어가는 방식
- 검색 시간을 최소화, 빠른 할당
- 잉여 공간을 고려하지 않으므로 메모리 공간 활용이 좋지 않을 수 있음.

#### 최적 적합

- Best-Fit
- 비어있는 공간을 모두 탐색한 다음, 들어갈 수 있는 비어있는 공간 중 최소의 크기를 가진 공간에 할당
- 잉여 공간이 적으므로 메모리 공간 활용은 좋음.
- 검색 시간이 길어짐

#### 최악 적합

- Worst-Fit
- 비어있는 공간을 모두 탐색한 다음, 들어갈 수 있는 공간 중 가장 큰 공간에 할당
- 검색 시간 길고 메모리 공간 활용이 좋지 않음

<br><br><br>

### 가상 메모리

- 물리 메모리에는 사용하는 부분만 적재하고, 나머지는 보조 기억 장치에 두고 스와핑을 이용해서 실제로 더 많은 물리 메모리가 필요하더라도 사용할 수 있게 함
- 페이징(고정 크기 메모리 공간)과 세그멘테이션(가변 크기 메모리 공간)을 사용

<br><br><br>

### 페이징

- 외부 단편화가 발생한 근본적인 문제는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문
- 모든 프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당함으로써 외부 단편화를 해결
- 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고, 물리 공간을 프레임이라는 페이지와 동일한 크기의 단위로 자른 뒤, 페이지와 프레임을 할당하는 가상 메모리 관리 기법
- 페이지는 연속되어 보이는 논리 주소이고, 실제 프레임은 불연속적으로 흩어져 있음
- 페이징을 사용함으로써 프로세스 단위의 스왑이 아니라, 페이지 단위의 스왑이 발생함
- 페이징을 통해서 외부 단편화를 해결할 수 있지만, 내부 단편화가 생길 수 있음.
- 페이지의 크기는 대부분 4KB임 (모든 페이지가 같은 크기를 가지는 것은 아님, 리눅스를 포함한 일부 운영체제는 예외적으로 큰 페이지가 존재할 수도 있음)

<br><br><br>

### PTBR

- Process Table Base Register
- 연속적으로 할당된 페이지와 불연속적인 프레임을 매핑하기 위해 프로세스마다 페이지 테이블이 존재.
- 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터 (PTBR)이 가리킨다.
- 즉, 실제 물리 공간 주소인 프레임을 사용하기 위해 페이지를 사용해야 하고, 페이지를 프레임으로 매핑시키기 위해 페이지 테이블을 알아야 한다.
- 페이지 테이블을 사용하려면 마찬가지로 페이지 테이블 주소를 알아야 하는데, 이는 PTBR에 저장되어 있다.
- 페이지 테이블이 메모리에 있으면 메모리 접근 시간이 2배가 되기 때문에 이는 옳지 않을 수 있음 (메모리는 레지스터나 캐시보다 접근 속도가 느리기 때문)

<br><br><br>

### TLB

- Translation Lookaside Buffer
- CPU 곁에 페이지 테이블의 캐시 메모리
- 페이지 테이블의 일부를 가져와 저장
- 접근하려는 논리 주소가 TLB에 있다면 한 번의 메모리 접근으로 사용가능, TLB에 없다면 메모리 두 번 접근으로 사용가능

<br><br><br>

### 페이징에서의 주소 변환

- 특정 주소에 접근하고자 한다면 어떤 정보가 필요할까?
- 어떤 페이지/프레임에 접근하고 싶은지, 사용하고자 하는 명령 및 자원이 해당 페이지 혹은 프레임에서 몇번째 인덱스에 있는지
- <페이지 번호, 변위> 를 페이지 테이블을 통해 <프레임 번호, 변위>로 변환된다.

<br><br><br>

### 페이지 테이블 엔트리

- 페이지 테이블의 각각의 행을 페이지 테이블 엔트리(PTE)라고 부름
- PTE에는 페이지 번호, 프레임 번호 쌍 외에도 아래와 같은 것들을 저장함.

- 유효 비트 : 현재 해당 페이지에 접근 가능한 지 여부 (현재 페이지가 스왑 영역에 있는 지, 메모리에 적재되어 있는 지를 나타냄)
- 만약 유효 비트가 0인 페이지에 접근하려고 한다면, 페이지 폴트라는 인터럽트가 발생해서 현재 작업 내역을 백업하고, 스왑 영역에 있는 프레임을 메모리 공간으로 올려서 유효 비트를 1로 바꾼다.

- 보호 비트 : 페이지 보호 기능을 위해 존재하는 비트 (읽기 전용 페이지, 읽기/쓰기 페이지를 표시)
- 외에 r,w,x로 읽기, 쓰기, 실행을 표현하기도 함

- 참조 비트 : CPU가 이 페이지에 접근한 적이 있는 지 여부
- 한 번이라도 CPU가 방문한 적이 있으면 1, 없으면 0

- 수정 비트 : dirty 비트라고도 부르며 CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
- 수정된 적이 있다면 1, 없으면 0 (물리 메모리, 보조 기억 장치의 데이터 동기를 맞추기 위해서 존재, 만약 쓴 적이 있다면 보조 기억 장치에 새롭게 쓰기 작업이 들어가야 함)

<br><br><br>

### 요구 페이징

- Demanding Paging
- 처음부터 모든 페이지를 적재하지 않고, 필요한 페이지만을 메모리에 적재하는 기법
- 요구되는 페이지만 적재하는 기법

1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 페이지가 현재 메모리에 있을 경우 _(유효 비트가 1)_, CPU는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우 _(유효 비트가 0)_, 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 수행한다.

<br><br><br>

### 페이지 교체 알고리즘

- 요구 페이징 기법으로 페이지들을 적재하다보면, 언젠가 물리 메모리가 가득 차게 됨.
- 이 때 당장 실행에 필요한 페이지를 남겨두고 불필요한 페이지를 보조기억장치로 swap out 시켜야 함
- 무엇이 좋은 페이지 교체 알고리즘일까? -> 페이지 폴트가 적은 알고리즘 _(보조기억장치에 접근해야되므로 속도가 매우 느려짐)_
- 페이지 폴트 횟수를 어떻게 알 수 있을까? -> 페이지 참조열 _(CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열)_

#### FIFO

- First In First Out
- 가장 단순한 방식
- 먼저 들어온 페이지를 먼저 내보냄
- 먼저 적재되었다고 내쫓는 것은 마땅하지 않을 수 있음 _(프로그램 실행 내내 계속 사용되는 페이지일 수도 있음)_
- 이를 보완하기 위해 나온 것이 2차 기회 페이지 교체 알고리즘 _(참조 비트가 1일 경우면 한번 더 기회를 줌 1로 되어있는 참조 비트를 0으로 바꾸고 적재 시간을 현재로 재설정, 0일 경우 swap out)_

#### 최적 페이지 교체 알고리즘

- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
- 가장 낮은 페이지 폴트율을 보장하는 페이지 알고리즘이지만, 현실적으로 구현이 어려움

#### LRU

- Least Recently Used
- 최적 페이지 교체 알고리즘 : 가장 오래 사용되지 않을 페이지 교체
- LRU 페이지 교체 알고리즘 : 가장 오래 사용되지 않은 페이지 교체

#### LFU

- Least Frequency Used
- 가장 많이 사용되지 않은 페이지 교체

### 스래싱

#### 페이지 폴트가 자주 발생하는 이유?

- 나쁜 페이지 교체 알고리즘을 사용해서
- 프로세스에 할당된 프레임 자체가 적어서

#### 스래싱

- 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 CPU 사용률이 떨어지게 되는 현상
- 동시에 실행되는 프로세스를 과도하게 늘리게 될 경우, 페이징에서 스왑이 많이 발생하므로 스래싱이 일어날 가능성이 높아질 수 있음
- 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문에 발생
- 각 프로세스가 필요로하는 최소한의 프레임 수를 파악하고 할당해주어야 함

<br><br><br>

### 프레임 할당

#### 균등 할당

- 가장 단순한 할당 방식
- 모든 프로세스에게 균등하게 프레임을 할당하는 방식

#### 비례 할당

- 프로세스의 크기를 고려해서 프레임을 할당
- 크기가 큰 프로세스일지라도 막상 많은 프레임을 요하지 않을 수도 있고,
- 크기가 작더라도 많은 프레임을 요할 수도 있음.
- 결국 프로세스가 필요로 하는 프레임 수는 실행해봐야 앎.

#### 작업 집합 모델

- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
- CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 된다.
- 작업 집합이란, "실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합"

#### 페이지 폴트 빈도

- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 두 개의 가정에서 생격난 아이디어
- 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
- 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있다.

<br><br><br>

### 쓰기 시 복사

- 프로세스가 복사될 때 페이징을 사용한다면 동일한 프레임 주소를 가리킴.
- 만약 쓰기 작업이 발생한다면 그 때 새로운 메모리를 할당함.
- 이를 통해 fork()시 프로세스 생성 시간 및 메모리를 절약할 수 있음.

<br><br><br>

### 계층적 페이징

- 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식
- 모든 페이지 테이블을 항상 메모리에 올려둘 필요가 없어짐 _(CPU와 가장 가까이 위치한 페이지 테이블만 유지하면 됨)_
- <바깥 페이지 번호, 안쪽 페이지 번호, 변위> 형태로 저장됨.