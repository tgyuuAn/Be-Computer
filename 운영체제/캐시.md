### 캐시 메모리 란?

- CPU의 작업 처리 속도가 주기억장치의 접근 속도보다 매우 빨라서 나온 SRAM 기반 메모리
- CPU와 주기억장치 사이에 위치하며 접근 속도가 주기억장치보다 훨씬 빠름
- CPU의 사용률이 주기억장치 접근 속도 때문에 손해를 보기에 그것을 메꾸어주려고 나온 메모리

<br><br><br>

### 참조 지역성의 원리

- 캐시 메모리는 메모리보다 용량이 적다
- 당연하게도 메모리의 모든 내용을 저장할 수 없다
- CPU가 자주 사용할 법한 내용을 예측해서 캐시 메모리에 저장하자.
- 캐시 히트 : 예측이 들어맞았을 경우, 주기억장치를 탐색하지 않아도 됨
- 캐시 미스 : 예측이 들어맞지 않았을 경우, 주기억장치를 추가적으로 탐색해야 함

#### 시간적 지역성

- 특정 데이터에 한 번 접근했을 경우, 가까운 미래에 또 한 번 데이터에 접근할 가능성이 높다.
- for문과 같은 반복문이나 함수 호출에 의해서 한번 더 호출될 수 있음

#### 공간적 지역성

- 특정 데이터에 한 번 접근했을 경우, 가까운 곳에 위치한 데이터에 접근할 가능성이 높다.
- 캐시 메모리는 어떠한 메모리에 접근할 때 해당 메모리 뿐만 아니라 해당 메모리가 포함된 블록을 들고온다.
- 배열과 같은 데이터는 연속된 논리적 주소에 데이터가 적재된다.

#### 순차적 지역성

- 데이터가 메모리에 저장된 순서대로 호출될 가능성이 높다.

<br><br><br>

### 파레토의 법칙

- 전체의 20%가 80%의 결과를 발생시킨다.

<br><br><br>

### 캐시 교체 알고리즘

#### LRU

- Least Recently Used
- 가장 오랫동안 사용되지 않은 메모리를 제거
- 내부적으로 LinkedList + HashMap으로 구현되어있음

#### LFU

- Least Frequently Used
- 가장 빈번하게 사용되지 않은 메모리를 제거

#### FIFO

- First In First Out
- 가장 먼저 들어온 메모리를 제거

<br><br><br>

### 멀티 코어 시스템에서 캐시의 일관성을 보장하는 방법

- 주로 MESI 프로토콜을 이용해 일관성 유지
- Modified : 해당 메모리가 현재의 캐시 메모리에만 있음. 메모리와 내용 불일치
- Exclusive : 해당 메모리가 하나의 캐시 메모리에만 있음. 메모리와 내용 일치
- Shared : 해당 메모리가 여러 캐시 메모리에 있음. 메모리와 내용 일치
- Invalid : 다른 캐시에서 해당 메모리에 쓰기 동작을 하였음. 유효하지 않은 데이터

1. 메모리의 X 라는 데이터가 공유 데이터라고 가정, 코어는 A,B 2개가 있다고 가정
2. 먼저 코어 A에서 X를 요청 -> 캐시 미스이므로 메모리에서 캐시 A에 X 적재 _(캐시 A에만 X가 존재하므로 Exclusive)_
3. 코어 B에서도 X를 요청 -> 캐시 미스이므로 메모리에서 캐시 B에 X 적재 _(캐시 A, 캐시 B 두 군데에서 사용되므로 둘 다 Shared로 변경됨)_
4. 코어 A에서 X 데이터 변경 -> 쓰기 작업이 들어갔으므로 캐시 A에 있는 X는 Modified로 바뀌고, 캐시 B에 있는 X는 Invalid로 바뀜
5. 코어 B에서 X를 요청했을 경우 -> Invalid이므로 캐시 미스 이므로 메모리에 데이터 요청 -> 
캐시 A의 Modified에서 이 요청에 응답하여 캐시 A에 있던 수정된 데이터를 메모리에 올린 뒤 상태를 Shared로 변경, 캐시 B도 수정된 데이터를 받은 뒤 Shared로 변경

#### 어떻게 캐시 A에서 캐시 B가 데이터를 요청하는 것을 알아차렸을까 ?

- 메모리에 접근하거나 요청할 때, 메모리 주소가 주소 버스를 통해 전체 캐시로 브로드캐스팅됨
- 다른 코어의 캐시들도 해당 메모리 주소를 가지고 있는 지 체크하면서 일관성을 유지