### 이중 모드

- CPU가 명령어를 실행하는 모드를 크게 유저 모드와 커널 모드로 구분하는 방식

#### 사용자 모드

- 운영체제 서비스를 제공받을 수 없는 실행 모드
- 커널 영역의 코드를 실행할 수 없는 모드
- 자원 접근 불가

#### 커널 모드

- 운영체제 서비스를 제공받을 수 있는 모드
- 자원 접근 가능

#### 사용자 모드 _(유저 모드)_ 와 커널 모드를 구분하는 이유?

- 어떤 프로세스든 간에, 함부로 커널 영역에 접근하지 못하도록 막아두는 것
- 각 프로세스에게 할당된 메모리마다 유저 모드 공간과 커널 모드 공간이 할당됨
- 이 때 할당되는 커널 모드 공간은 모든 프로세스에서 공유되는 공간임
- 즉, 커널 함수를 호출하려고 할 때 커널 모드로 전환한 뒤 호출해야 하며, 커널 모드에서는 보안을 강화하는 등의 행동을 함
- 커널 스택은 각 프로세스 _(스레드)_ 마다 따로 할당되는데, 커널이 공유되는 공간이라고 하더라도 호출되는 프로세스 컨텍스트는 유지하고 있으므로 돌아갈 때 안전하게 돌아갈 수 있음

<br><br><br>

### 사용자 모드에 비해 커널 모드가 비용이 더 큰 이유

- 사용자 모드 -> 커널 모드로 전환될 때, 사용자가 사용하던 프로세스의 레지스터 및 스택을 저장해야 함
- 기존에 사용하던 캐시가 모두 무효화되는 캐시 플러시가 발생할 수 있음
- 기존에는 사용하던 프로세스의 메모리 주소만 접근할 수 있었지만, 이제는 모든 메모리 주소에 접근이 가능함으로 주소 탐색 시간에서 더 걸릴 수도 있음 _(TLB 캐시도 무효화 될 수 있고)_
- 기존에는 유저 스택을 통해서 스택 메모리를 쌓았지만, 커널 모드에서는 커널 스택을 사용하므로 스택 전환이 필요
- Mode Switching 외에도 커널 내부에서는 추가적인 보안 검사가 발생하기 때문에 사용자 모드에서의 명령어 호출보다 커널 모드에서의 명령어 호출이 더 많은 시간이 걸림
- 커널 모드에서는 선점형 스케줄링의 영향을 받을 수도 있으므로 더 높은 우선순위의 인터럽트에 의해 실행순서가 밀릴 수 있음

<br><br><br>

### 시스템 호출

- 커널 모드로 전환하여 실행하기 위해 호출
- 일종의 소프트웨어 인터럽트임. (시스템 호출 -> 커널 내 운영체제 코드 실행 -> 시스템 호출 복귀)

<br><br><br>

### fork()

- 부모 프로세스와 동등한 자식 프로세스를 복제함.

<br><br><br>

### wait()

- 자식 프로세스가 종료할 때 까지 대기

<br><br><br>

### exec()

- fork()와 달리 부모와 다른 동작을 하는 프로세스를 만들 때 사용
- 이 때 실행 파일을 넣어주면 실행 파일의 코드를 부모 프로세스에 덮어쓴 자식 프로세스가 생성됨.
