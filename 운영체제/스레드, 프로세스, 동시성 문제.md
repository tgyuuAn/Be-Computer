### 프로그램이란 ?

- 어떤 작업을 위해 실행할 수 있는 파일

<br><br><br>

### 프로세스란 ?

- 컴퓨터에서 실행되고 있는 프로그램
- 메모리에 올라와 있는 프로그램의 인스턴스 (독립적인 개체, 두개 실행하면 두개 생김)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 실행된 프로그램을 의미
- 할당받는 시스템 자원 (CPU, 운영에 필요한 주소 공간, 메모리 영역)

<br><br><br>

### 프로세스의 메모리 영역

- 프로세스는 각각 독립적인 (코드, 데이터, 힙, 스택) 영역을 갖게된다.

- 코드 : 코드 자체를 구성하는 메모리 영역 (프로그램 명령, 진짜 코드 그 자체임)
- 힙 : 동적 할당 시 사용 (new(), malloc() 등)
- 스택 : 지역 변수, 매개 변수, 리턴 값 (전역 변수랑 정적 변수 빼고, 임시 메모리 영역)
- 데이터 : 전역 변수, 정적 변수, 배열 등

- 초기화된 데이터는 Data 영역에 저장
- 초기화되지 않은 데이터는 BSS 영역에 저장 (여기서 말하는 BSS 영역이란, Block Started by Symbol의 약자로 초기화되지 않은 전역 변수나 정적 변수가 저장되는 메모리 영역임)

<br><br><br>

### BSS 영역?

전역 변수와 정적 변수의 초기화 여부: 전역 변수나 정적 변수는 선언 시 초기값을 명시하지 않으면 기본적으로 초기화되지 않은 것으로 간주되어 BSS 영역에 배치된다.

```c
int globalVar;        // 초기값이 명시되지 않으므로 BSS 영역에 위치, 실행 시 0으로 초기화됨
static int staticVar; // 함수 내 또는 파일 범위에서 선언된 정적 변수도 초기값 미지정 시 BSS 영역에 위치
```

반면,

```c
int globalVar = 10;        // 명시적 초기화로 data 영역에 위치
static int staticVar = 20; // 명시적 초기화로 data 영역에 위치
```

이렇게 초기화 값을 지정하면, 그 값이 실행 파일에 저장되고 data 영역에 배치된다.

왜 구분하는가?
- 초기화되지 않은 변수들은 실행 파일에 초기값을 저장하지 않아도 되므로 실행 파일의 크기를 줄이고, 메모리 할당을 보다 효율적으로 관리할 수 있기 때문.

<br><br><br>

![alt text](image.png)

- 프로세스는 기본적으로 최소 1개의 스레드 영역을 가지고 있음.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 IPC(inter-process-communication)을 사용해야 함

<br><br><br>

### 스레드란 ?

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위

![alt text](image-1.png)

- 프로세스에서 할당받은 자원 중에 스택과 레지스터를 빼고 다른 영역은 공유.

#### 스택을 따로 할당하는 이유 ?

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것.
이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.
즉, 독립적인 실행 흐름이 추가되는 것

#### 레지스터를 따로 할당하는 이유 ?

PC 레지스터는 다음번에 실행될 명령어를 기억하는 레지스터이다. 스레드가 스위칭 되더라도 PC 레지스터를 남겨둠으로써 어디까지 명령어를 실행했는 지를 기억하고,
해당 레지스터를 기점으로 다시 작업을 재개시키므로 각 스레드를 독립적으로 홛동시키기 위해서 필요하다.

<br><br><br>

즉, 프로세스는 자신만의 고유한 독립적인 자원을 OS로부터 할당받지만, 스레드는 별도로 자원을 할당받지 않고 동일한 프로세스 내에서 레지스터와 스택을 제외하고 공유 자원을 사용함. 

<br><br><br>

### 멀티 프로세스란 ?

- 하나의 작업을 수행하기 위해 여러 개의 프로세스를 만들어 자원을 할당받고 작업하는 방식.
- 프로세스는 각각 독립적인 메모리 영역을 가지기 때문에, 다른 프로세스가 서로의 메모리 자원을 침범하지 못함.

#### 장점

- 각 메모리가 OS의 관리에 의해 다뤄지므로 메모리를 안정적으로 사용할 수 있음
- 하나의 프로세스가 죽어도 다른 프로세스에서는 안전하게 동작 가능

#### 단점

- Context Switching 비용이 큼
- 케시 무효화가 발생함
- 높은 메모리 사용량
- 프로세스간 통신을 위해 IPC를 사용해야 함.

<br><br><br>

### 멀티 스레드란 ?

- 하나의 프로세스 내에서 여러 개의 독립된 실행 흐름(스레드)을 생성하여 동시에 작업을 수행하는 방식

#### 장점

- 멀티 프로세스에 비해서 Context Switching 비용이 적음
- 공유된 자원을 사용하므로 성능상으로도 더 우수함
- 멀티 프로세스 방식은 프로세스 간 통신을 IPC로 하는 데에 반해, 멀티 스레드 방식은 공유 메모리를 이용해서 하므로 훨씬 가벼움

#### 단점

- 하나의 스레드에서 공유 자원을 훼손시키면 그 자원을 사용하는 이외의 스레드들도 모두 고장나버림.
- 공유된 자원을 동기화하지 않으면 Race Condition, Deadlock과 같은 문제가 생길 수 있음.

<br><br><br>

### Race Condition

- 공유 자원에 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태
- 여러 개의 프로세스가 동일한 메모리에 접근할 때 생김
- 커널 작업을 수행하는 도중 인터럽트가 발생하여 동일한 메모리를 건드림
- 커널 작업을 수행하는 도중 타임아웃으로 인해 다른 스레드에 작업 권한이 넘어감. 이 때 동일한 메모리를 건드림

<br><br><br>

### Thread-Safe란?

- 멀티 스레드 환경에서 여러 개의 스레드가 공유 자원에 접근할 때, 의도한 대로 동작하는 것을 "Thread-Safe하다" 라고 말한다.
- 이는 공유 자원에 접근하는 Critical Section(임계 영역)을 동기화 하는 기법으로 제어해야 한다.
- 동기화 기법으로는 Mutex나 Semaphore 등이 있다.

<br><br><br>

### 스레드 동기화 방법

#### 실행 순서의 동기화

- 스레드의 실행순서를 정하고 이 순서에 반드시 따르도록 하는 것

#### 메모리 접근에 대한 동기화

- 메모리 접근에 있어서 동시접근을 막는 것, 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황을 의미

<br><br><br>

### 동기화 기법의 종류

#### 유저 모드 동기화

- 동기화가 진행되는 과정에서 커널 코드가 실행되지 않는 동기화 기법
- 동기화를 위해서 커널 모드로의 전환이 불필요하므로 성능상의 이점이 있음
- 하지만, 그 만큼 기능성의 제한도 존재함
- JVM이나 .NET과 같은 어플리케이션 수준에서 사용하는 동기화 기법. Ex) 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화

#### 커널 모드 동기화

- 커널에서 제공하는 동기화 기능을 활용하는 방법
- 동기화에 관련된 함수가 호출될 때마다 커널 모드로의 전환이 필요하고, 이는 성능의 저하로 이루어짐
- 하지만 그 만큼 유저 모드에서 사용하지 못하는 기능들도 사용할 수 있음.
- 운영체제 수준에서 사용하는 동기화 기법 시스템 콜과 같은 것들에 사용됨. Ex) 뮤텍스 기반의 동기화, 세마포어 기반의 동기화, 이름있는 뮤텍스 기반의 프로세스 동기화, 이벤트 기반의 동기화

<br><br><br>

### Mutex Lock

- 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
- 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section 에 진입하는 프로세스는 Lock 을 획득하고 Critical Section 을 빠져나올 때, Lock 을 방출함으로써 동시에 접근이 되지 않도록 한다.
- 뮤텍스는 0,1로 이진 세마포어라고 부르기도 함
- Context Switching이 발생하기 때문에 임계 구역의 실행 시간보다 Context Switching 시간이 더 클 경우 성능상 불이익이 있음

<br><br><br>

### Semaphore

- 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
- 가용한 개수를 가진 자원 에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 자원의 개수 로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가 한다.
- 초기 버전에는 SpinLock 기법을 사용하여 Busy Waiting 문제가 발생하였음. 이후에는 임계 영역에 진입하다가 실패한 스레드의 경우 block을 시킨 뒤 임계 영역 작업이 끝났을 때 꺠우는 방식으로 해결할 수 있음.

<br><br><br>

### SpinLock

- 임계 영역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
- 임계 영역에서 이미 실행중인 스레드가 있을 경우 해당 영역을 원하는 작업은 계속해서 임계 영역을 확인함 (Busy Waiting)
- 임계 영역 내부의 작업 시간이 ContextSwitching 시간 보다 길 경우 Busy Waiting으로 인해 버려지는 CPU 점유 시간이 더 크기 때문에 SpinLock은 적절하지 않음.
- 반면, 임계 영역 내부 작업 시간이 ContextSwitching 시간 보다 짧을 경우 불필요한 ContextSwitching이 발생하지 않으므로 오히려 성능상으로 더 좋을 수 있음.

<br><br><br>

### DeadLock

- 두 개 이상의 프로세스나 스레드가 서로의 자원을 얻지 못해서 다음 작업을 처리하지 못하고 무한히 기다리는 상태
- 한정된 자원을 여러 곳에서 사용하려고 할 때 생김

#### 발생하는 이유?

- 상호 배제 (한 번에 하나의 프로세스만 메모리에 접근할 수 있음)
- 점유 대기 (자원을 소지한 채로 기다림)
- 순환 대기 (순환 형태로 프로세스가 자원을 대기하고 있음)
- 비선점 (다른 프로세스가 자원을 선점하고 있을 경우 해당 자원을 빼앗을 수 없음)

### DeadLock을 해결하는 방법

#### 예방

- 위 4개 중 하나라도 이뤄지지 않으면 DeadLock은 이뤄지지 않음.

- 상호 배제 부정 : 여러 프로세스가 공유 자원을 사용 (현실적으로 불가능한 방법)
- 점유 대기 부정 : 프로세스 실행 전, 해당 프로세스에 필요한 모든 자원을 할당 (자원 활용률이 떨어질 수 있음)
- 점유 대기 부정 : 자원을 점유하고 있지 않을 때에만 다른 자원을 요청할 수 있도록 함 (기아 상태가 될 수 있음)
- 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 만약 가질 수 없다면 가진 자원을 모두 반납하고, 새 자원과 이전 자원을 얻을 수 있을 떄 까지 대기
- 순환 대기 부정 : 자원에 고유 부여 후 순서대로 자원 요구 (모든 자원에 번호를 붙이는 것이 어려움. 어떤 자원에 어떤 번호를 붙이느냐에 따라 자원 활용률이 달라짐)

![alt text](image-2.png)

- 예방을 사용하면 교착 상태를 발생하지는 않을 수는 있으나, 부작용이 발생함

#### 회피

- 교착 상태를 무분별한 자원 할당으로 인해 발생했다고 간주
- 자원을 할당할 때 조심 조심 할당
- 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 만큼만 자원 배분

- 안전 순서열 : 교착 상태 없이 안전하게 프로세스들에게 자원을 할당할 수 있는 순서 ex) A, B, C 순서로 할당하니까 교착 상태가 발생하는데, B, C, A로 할당하니까 발생하지 않네? 이는 안전 순서열이겠구나.
- 안전 상태 : 교착 상태 없이 모든 프로세스가 자원을 할당받고 종료할 수 있는 상태. 안전 순서열이 있는 상태
- 불안전 상태 : 교착 상태가 발생할 수도 있는 상태. 안전 순서열이 없는 상태

- 즉, 안전 상태 -> 안전 상태로 움직이는 경우에만 자원을 할당하는 방식

https://www.youtube.com/watch?v=zQDNXklvdUw&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl&index=38

#### 탐지 및 회복

- 교착 상태의 발생을 인정하고 사후에 조치하는 방식
- 프로세스가 요구하면 일단 자원 할당, 교착 상태가 검출되면 회복
- 선점을 통한 회복 : 교착 상태가 해결될 때 까지 한 프로세스에 자원을 몰아주는 방식
- 프로세스 강제 종료를 통한 회복 등이 있음 (타조 알고리즘)

#### 식사하는 철학자

- 교착 상태를 나타내기 위해 다익스트라가 고안한 예시의 문제
- 둥근 원탁에 n명의 철학자가 있고, n개의 포크가 철학자들 사이사이에 있음.
- 철학자들은 먼저 왼쪽 포크를 든 다음 오른쪽 포크를 들고, 두 개의 포크가 모두 쥐어졌을 때 식사를 시작함.
- 식사를 마친 뒤 오른쪽 포크를 책상위에 두고 왼쪽 포크를 책상 위에 둠.
- 위와 같은 규칙이 있을 때, 모든 철학자가 동시에 식사를 하려고 하면 그 어떤 철학자도 식사를 하지 못함.
- 이에 대한 해결책은 한 명이라도 포크를 늦게 들면 한 사람이라도 식사를 시작할 수 있으므로 해결됨. (즉, 순환 대기를 부정하는 방법)

#### 뱅커 알고리즘

- 교창 상태를 회피하는 방법에서 소개된 것과 같이, 안전 상태에서 안전 상태로 이동할 수 있는 경우에만 자원을 할당하는 방식
